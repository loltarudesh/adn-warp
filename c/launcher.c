#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/if.h>
#include <linux/if_tun.h>
#include <sys/ioctl.h>
#include <pwd.h>
#include <grp.h>
#include <sys/stat.h>
#include <sys/types.h>

#define MAX_IFACE_NUMBER        10              // Arbitrary, but would we ever really need more?? might be a system limit, would be more elegant...
#define POP_ARGS                3               // number of arguments consumed by the launcher

/*              THIS IS A LAUNCHER FOR ADN 
 *
 *  it's purpose is to keep all root calls contained in a small and easy to unterstand part of the code,
 *  and execute the main program without priviledges.
 *
 *  Most of it is in the before.hs script, generated by ADN for a specific program with the command genconf.
 *  This program's purpose is to handle the generation and the access to a virtual TUN interface, 
 *  which cannot be done in bash (to our knowledge).
 *
 *
 *  The execution is quite straight forward:
 *      
 *      - [ROOT] Create a Tun interface
 *
 *      - [ROOT] execute the script before.sh
 *
 *      - drop priviledge
 *
 *      - execute the main program
 *
 *
 *  this program must be executed with priviledges.
 *  It should however be owned by a simple user, with no special rights:
 *  before running the main program, it will set the execution UID and GID to the ones of the program's owner.
 *
 *  In order to access the TUN interface from the main program, a file descriptor to it is passed in argument
 *  as the value of the option "--tun-fd"
 *
 */


int tun_alloc(char *dev, int flags);               // create a TUN interface, and return a file descriptor to access it
int set_uid_gid(int uid, int gid);                 // set the execution to the provided UID and GID
int get_owner_uid (char* filename);                // return the UID of a file's owner (return -1 if failed to access the file)
int get_owner_gid (char* filename);                // return the GID of a file's owner (return -1 if failed to access the file)
int read_tun_names(char* tun_file, char** names);  // read the names of the TUN interfaces needed by ADN
int write_tun_fd(char* tun_file, int nb_iface, char** names, int* ifaces_fd);


int main (int argc, char** argv){

        // Retreiving arguments specific to the main
    if (argc < POP_ARGS + 1){
        printf("error: argc=%d\n",argc);
        return EXIT_FAILURE;
    }   
    char* adn_exe = argv[1];        // path to the main ADN program exe file, executed without root
    char* script_before = argv[2];  // path to the script to call before ADN, executed with root
    char* tun_file = argv[3];       // path to the file containing the name of the TUN interface to create, also used to exchange file descriptors
    
                    // Retreive the UID and GID of the owner of the C program
    int uid = get_owner_uid(argv[0]);
    if(-1 == uid) return EXIT_FAILURE;
    int gid = get_owner_gid(argv[0]);
    if(-1 == gid) return EXIT_FAILURE;
    printf("Current uid: %d gid: %d. We will fall back to uid: %d and gid:%d\n", getuid(), getgid(), uid, gid);


    char** names = (char**) malloc(MAX_IFACE_NUMBER*sizeof(char*));
    for(int i=0; i<MAX_IFACE_NUMBER;i++)
        names[i] = (char*) malloc(IFNAMSIZ*sizeof(char*));
    int ifaces_fd[MAX_IFACE_NUMBER];
    int nb_iface = read_tun_names(tun_file, names);

                            // ##### PRIVILEDGED ACTION #####
                            
    for(int i=0; i<nb_iface; i++){
                    // create the TUN interface
            printf("[ROOT] creating tun interface %s\n",names[i]);
            ifaces_fd[i] = tun_alloc(names[i], IFF_TUN | IFF_NO_PI);
    }

            // execute the before script
    printf("[ROOT] Running script : %s\n", script_before);
    system(script_before);

        
                            // ##### DROPPING PRIVILEDGE #####
    
    if(-1 == set_uid_gid(uid,gid)) return -1;  // if we cannot drop to user, abort the execution
    printf("Current uid: %d gid: %d\n", getuid(), getgid()); // confirm that the root has been dropped


            // Write the file descriptors to the tun_file
    if(0 > write_tun_fd(tun_file, nb_iface, names, ifaces_fd))
        return EXIT_FAILURE;
    


            // Copying the arguments (without the arguments specific to this program)
    char* args[argc - POP_ARGS+1];
    for (int i=1; i+POP_ARGS < argc; i++){
        args[i] = argv[i+POP_ARGS];
    }
    args[argc-POP_ARGS]=NULL;

            // run-adn script
    args[0] = adn_exe;          // Replace the first arguments by the main ADN program file
    execvp(adn_exe, args);      // Execute the main ADN program
    perror("program terminated unexpectedly");      //execvp should not return if call succeed
    return EXIT_FAILURE;
}


int set_uid_gid(int uid, int gid){
    if (getuid() == 0){
        printf("Dropping privilleges...\n");
        if (setgid(gid) != 0){
            printf("Cannot drop group permissions\n");
            return -1;
        }
        if (setuid(uid) != 0){
            printf("Cannot drop user permissions\n");
            return -1;
        }
    }
    return 0;
}

/* from https://backreference.org/2010/03/26/tuntap-interface-tutorial/ */
int tun_alloc(char *dev, int flags) {

  struct ifreq ifr;
  int fd, err;
  char *clonedev = "/dev/net/tun";

  char name[IFNAMSIZ];
  bzero(name,IFNAMSIZ);
  strncpy (name, dev, IFNAMSIZ);

  /* Arguments taken by the function:
   *
   * char *dev: the name of an interface (or '\0'). MUST have enough
   *   space to hold the interface name if '\0' is passed
   * int flags: interface flags (eg, IFF_TUN etc.)
   */

   /* open the clone device */
   if( (fd = open(clonedev, O_RDWR)) < 0 ) {
     printf("open(%s,O_RDWR) has failed.\n", clonedev);
     return fd;
   }

   /* preparation of the struct ifr, of type "struct ifreq" */
   memset(&ifr, 0, sizeof(ifr));

   ifr.ifr_flags = flags;   /* IFF_TUN or IFF_TAP, plus maybe IFF_NO_PI */

   if (*dev) {
     /* if a device name was specified, put it in the structure; otherwise,
      * the kernel will try to allocate the "next" device of the
      * specified type */
     strncpy(ifr.ifr_name, dev, IFNAMSIZ);
   }

   /* try to create the device */
   if( (err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0 ) {
     perror("failed to create the device");
     close(fd);
     return err;
   }

  /* if the operation was successful, write back the name of the
   * interface to the variable "dev", so the caller can know
   * it. Note that the caller MUST reserve space in *dev (see calling
   * code below) */
  strcpy(dev, ifr.ifr_name);

  /* this is the special file descriptor that the caller will use to talk
   * with the virtual interface */
  return fd;
}


    // return the UID of a file's owner (return -1 if failed to access the file)
int get_owner_uid (char* filename){
    int res;
    struct stat st;
    if (-1 == stat(filename,&st)){  
        printf("error: cannot access to the owner of %s\n", filename);
        return -1;
    }
    struct passwd* pwd = getpwuid(st.st_uid);  
    res = pwd->pw_uid;
    return res;
}

    // return the GID of a file's owner (return -1 if failed to access the file)
int get_owner_gid (char* filename){
    int res;
    struct stat st;
    if (-1 == stat(filename,&st)){
        printf("error: cannot access to the owner of %s\n", filename);
        return -1;
    }
    struct group* grp = getgrgid(st.st_gid);
    res = grp->gr_gid;
    return res;
}


// Reads the list of interface to create from the file tun_file
int read_tun_names(char* tun_file, char** names){
    char *line=NULL;
    size_t len = 0;
    ssize_t read;
    int nb_iface=0;

    FILE *fp = fopen(tun_file, "r");
    if (fp == NULL) exit(EXIT_FAILURE);

    read = getline(&line, &len, fp);
    while (-1 != read) {
        if (nb_iface + 1 > MAX_IFACE_NUMBER) {
            printf("Maximum number of TUN interface reached: %d\n",MAX_IFACE_NUMBER);
            break;
        }

        if (read < IFNAMSIZ + 1){
            strcpy(names[nb_iface], strtok(line, " ") );
            nb_iface++;
        }
        else {
            printf("cannot create interface, name too long: %s\nmaximum size allowed: %d", line, IFNAMSIZ);
        }
        read = getline(&line, &len, fp);
    }
    fclose(fp);

    return nb_iface;
}

int write_tun_fd(char* tun_file, int nb_iface, char** names, int* ifaces_fd){
            // Write the file descriptors to the tun_file
    FILE *fp = fopen(tun_file, "w");
    if (fp == NULL) exit(EXIT_FAILURE);
    
    for(int i=0; i<nb_iface; i++){
        fprintf(fp, "%s %d\n", names[i], ifaces_fd[i]);
        printf("%s:%d\n", names[i], ifaces_fd[i]);
        free(names[i]);
    }

    free(names);
    fclose(fp);
    return EXIT_SUCCESS;

}



